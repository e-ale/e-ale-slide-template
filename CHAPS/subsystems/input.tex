\section{Input Subsystem}

\begin{frame}
   {Overview}

   \begin{itemize}
      \item
	      The Linux Input subsystem is a framework to support all types of input devices
      \item
	      \url{https://www.kernel.org/doc/html/v5.0/input/input.html}
      \item
	      Consists of the core \textbf{input module}, \textbf{device drivers}, and \textbf{event handlers}
   \end{itemize}
\end{frame}

\begin{frame}
	{Device Drivers}

	\begin{itemize}
		\item
			\textbf{Device drivers} interface with hardware and provide events to the \textbf{input module}
		\item
			Examples are:
			\begin{itemize}
				\item
					\textbf{gpio\_keys}
				\item
					\textbf{hid-generic}
				\item
					\textbf{usbmouse}
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
	{Event Handlers}

	\begin{itemize}
      \item
	      \textbf{Event handlers} interface with the \textbf{input module} and pass events to other kernel subsystems or userspace
	\begin{itemize}
	\item
		\textbf{evdev} passes generic input events to userspace.
		Devices are in \textbf{/dev/input}:
			\begin{raw}
crw-r--r--   1 root     root      13,  64 Apr  1 10:49 event0
crw-r--r--   1 root     root      13,  65 Apr  1 10:50 event1
crw-r--r--   1 root     root      13,  66 Apr  1 10:50 event2
crw-r--r--   1 root     root      13,  67 Apr  1 10:50 event3
			\end{raw}
	\item
		\textbf{joydev} passes joystick events to userspace.
		Devices are in \textbf{/dev/input}:
			\begin{raw}
crw-r--r--   1 root     root      13,   0 Apr  1 10:50 js0
crw-r--r--   1 root     root      13,   1 Apr  1 10:50 js1
crw-r--r--   1 root     root      13,   2 Apr  1 10:50 js2
crw-r--r--   1 root     root      13,   3 Apr  1 10:50 js3
			\end{raw}
	\end{itemize}
   \end{itemize}

\end{frame}


\begin{frame}
	{evdev}

	\begin{itemize}
		\item
			\textbf{evdev} nodes support blocking/non-blocking \textbf{read} and \textbf{select}
		\item
			Reading an \textbf{evdev} node returns a \textbf{struct input\_event}:
			\begin{raw}
struct input_event
{
	struct timeval time;
	unsigned short type;
	unsigned short code;
	unsigned int value;
};
			\end{raw}
	\end{itemize}
\end{frame}

\begin{frame}
	{evtest}

	\begin{itemize}
		\item \textbf{evtest} can be used to test evdev events at the command line
		\item Example:
			\begin{rawscriptsize}
$ evtest /dev/input/event0
Input driver version is 1.0.1
Input device ID: bus 0x3 vendor 0x46d product 0x1028 version 0x111
Input device name: "Logitech M570"
Supported events:
Event type 0 (EV_SYN)
Event type 1 (EV_KEY)
Event code 272 (BTN_LEFT)
...
Event type 4 (EV_MSC)
Event code 4 (MSC_SCAN)
Properties:
Testing ... (interrupt to exit)
Event: time 1540159516.312712, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90001
Event: time 1540159516.312712, type 1 (EV_KEY), code 272 (BTN_LEFT), value 1
Event: time 1540159516.312712, -------------- SYN_REPORT ------------
			\end{rawscriptsize}
	\end{itemize}
\end{frame}

\begin{frame}
	{jstest}

	\begin{itemize}
		\item \textbf{jstest} can be used to test joystick events at the command line
		\item Example:
			\begin{rawscriptsize}
# jstest /dev/input/js0
Driver version is 2.1.0.
Joystick (python-uinput) has 2 axes (X, Y)
and 2 buttons (BtnA, BtnB).
Testing ... (interrupt to exit)
Axes:  0:  1028  1:  6425 Buttons:  0:off  1:off
			\end{rawscriptsize}
	\end{itemize}
\end{frame}

\begin{frame}
	{Input device driver API}
	\begin{itemize}
		\item
			Input devices described by \textbf{struct input\_dev}:
			\begin{rawfootnotesize}
struct input_dev {
	const char *name;
	...
	unsigned long evbit[BITS_TO_LONGS(EV_CNT)];
	unsigned long keybit[BITS_TO_LONGS(KEY_CNT)];
	...
	int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value);
	...
};
			\end{rawfootnotesize}
		\item
			A \textbf{struct input\_dev} is allocated using \textbf{devm\_input\_allocate\_device} before event types and codes are configured and handlers are filled in.
		\item
			\textbf{input\_register\_device} and \textbf{input\_unregister\_device} are used to register and unregister the device, respectively
	\end{itemize}
\end{frame}

\begin{frame}
	{Input polled device driver API}
	\begin{itemize}
		\item
			Simple devices that can to be polled on a timer basis can be implemented using the simpler \textbf{struct input\_polled\_dev}:
			\begin{rawfootnotesize}
struct input_polled_dev {
	...
	void (*poll)(struct input_polled_dev *dev);
	unsigned int poll_interval; /* msec */
	...
	struct input_dev *input;
};
			\end{rawfootnotesize}
		\item
			Allocate a \textbf{struct input\_polled\_dev} with \textbf{devm\_input\_allocate\_polled\_device}
		\item
			It is necessary only to fill in the \textbf{poll} handler, \textbf{poll\_interval}, and fill in the \textbf{input} device configuration (\textbf{name, id, evkey, keybit} fields and use \textbf{input\_set\_abs\_params} if absolute events are supported)
		\item
			Register the polled device with \textbf{input\_register\_polled\_device}
		\item
			In the \textbf{poll} handler, read the hardware and use \textbf{input\_report\_*} to queue events to be reported and \textbf{input\_sync} to flush the queued events
	\end{itemize}
\end{frame}
